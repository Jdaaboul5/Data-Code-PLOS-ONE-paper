import random
from random import choice
import numpy as np
import itertools
from itertools import permutations
import copy
import math
from scipy.cluster.hierarchy import linkage
import time

p0 = time.process_time()

# Parameters

# Parameters for products
# Set of products
I = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Due date for each product
D = [100, 150, 200, 250, 300, 350, 300, 250, 200, 400]
# Penalty of unit time tardiness for each product
W = [2, 1, 4, 5, 3, 9, 6, 8, 7, 10]

# Parameters for operations
# Set of operations
OP = [0, 1, 2, 3, 4]
MG = [[[1, 0], [1, 0, 0], [1, 0]],
      [[0, 1], [0, 1, 0], [0, 1]],
      [[1, 0], [0, 0, 1], [0, 1]],
      [[0, 1], [0, 1, 0], [1, 0]],
      [[0, 0], [1, 0, 1], [0, 0]]]

# Parameters for part variants
V = [0, 1, 2]  # Set of part variants
# Transfer time for moving a WIP belonging to each part variant in unit distance
FT = [1, 3, 5]
# Transfer cost for moving a WIP belonging to each part variant in unit distance
FC = [2, 4, 6]
# Holding cost for holding a WIP belonging to each part variant in unit time
HC = [0.5, 0.6, 0.4]
# Set of operations for each part variant
VP = [[0, 1, 2, 3, 4],
      [0, 1, 2, 3, 4],
      [0, 1, 2, 4]]

# Parameters for part variants-operations
K = [[[], [0], [0], [1], [1, 2]],
     [[], [], [0], [1, 2], [3]],
     [[], [0], [0], [], [0]]]
PT = [[[[3, 0], [5, 0, 0], [4, 0]],
       [[0, 8], [0, 5, 0], [0, 7]],
       [[1, 0], [0, 0, 2], [0, 3]],
       [[0, 9], [0, 7, 0], [6, 0]],
       [[0, 0], [2, 0, 1], [0, 0]]],
      [[[5, 0], [4, 0, 0], [6, 0]],
       [[0, 6], [0, 7, 0], [0, 8]],
       [[9, 0], [0, 0, 7], [0, 8]],
       [[0, 5], [0, 3, 0], [2, 0]],
       [[0, 0], [2, 0, 4], [0, 0]]],
      [[[5, 0], [2, 0, 0], [3, 0]],
       [[0, 9], [0, 9, 0], [0, 8]],
       [[4, 0], [0, 0, 2], [0, 5]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [7, 0, 6], [0, 0]]]]
PC = [[[[5, 0], [8, 0, 0], [6, 0]],
       [[0, 8], [0, 4, 0], [0, 6]],
       [[8, 0], [0, 0, 5], [0, 6]],
       [[0, 4], [0, 6, 0], [6, 0]],
       [[0, 0], [5, 0, 7], [0, 0]]],
      [[[6, 0], [8, 0, 0], [7, 0]],
       [[0, 4], [0, 9, 0], [0, 7]],
       [[6, 0], [0, 0, 4], [0, 3]],
       [[0, 7], [0, 4, 0], [8, 0]],
       [[0, 0], [4, 0, 5], [0, 0]]],
      [[[5, 0], [4, 0, 0], [7, 0]],
       [[0, 4], [0, 6, 0], [0, 4]],
       [[5, 0], [0, 0, 3], [0, 4]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [6, 0, 4], [0, 0]]]]
ST = [[[[5, 0], [4, 0, 0], [2, 0]],
       [[0, 5], [0, 6, 0], [0, 7]],
       [[8, 0], [0, 0, 9], [0, 8]],
       [[0, 4], [0, 2, 0], [3, 0]],
       [[0, 0], [6, 0, 8], [0, 0]]],
      [[[7, 0], [5, 0, 0], [6, 0]],
       [[0, 7], [0, 5, 0], [0, 4]],
       [[8, 0], [0, 0, 5], [0, 7]],
       [[0, 6], [0, 4, 0], [3, 0]],
       [[0, 0], [4, 0, 3], [0, 0]]],
      [[[3, 0], [1, 0, 0], [1, 0]],
       [[0, 4], [0, 3, 0], [0, 2]],
       [[6, 0], [0, 0, 3], [0, 5]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [8, 0, 6], [0, 0]]]]
SC = [[[[8, 0], [7, 0, 0], [9, 0]],
       [[0, 4], [0, 5, 0], [0, 3]],
       [[2, 0], [0, 0, 2], [0, 1]],
       [[0, 6], [0, 7, 0], [5, 0]],
       [[0, 0], [5, 0, 4], [0, 0]]],
      [[[8, 0], [6, 0, 0], [6, 0]],
       [[0, 6], [0, 4, 0], [0, 7]],
       [[5, 0], [0, 0, 4], [0, 3]],
       [[0, 6], [0, 8, 0], [7, 0]],
       [[0, 0], [4, 0, 8], [0, 0]]],
      [[[5, 0], [6, 0, 0], [5, 0]],
       [[0, 8], [0, 5, 0], [0, 6]],
       [[5, 0], [0, 0, 3], [0, 2]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [5, 0, 7], [0, 0]]]]

# Parameters for products-part variants
J = [[1, 1, 0],
     [1, 0, 1],
     [0, 1, 1],
     [2, 1, 0],
     [0, 2, 1],
     [2, 0, 1],
     [1, 1, 1],
     [1, 2, 0],
     [1, 0, 2],
     [0, 1, 2]]  # Number of each part variant in each product

# Parameters for workshop
BX = 12
BY = 9

# Parameters for machines
M = [0, 1, 2]  # Number of machines
LC = [1, 2, 3]  # Layout cost for moving each machine in unit distance
X = [2, 8, 6]  # Initial location for each machine on the X-coordinate
Y = [7, 3, 8]  # Initial location for each machine on the Y-coordinate
SX = [1, 3, 2]  # Security distance for each machine on the X-coordinate
SY = [1, 2, 1]  # Security distance for each machine on the Y-coordinate

# Parameters for configurations
G = [2, 3, 2]  # Number of configurations on each machine
# Reconfiguration time for between configurations on each machine
RT = [[[0, 1], [3, 0]],
      [[0, 5, 7], [9, 0, 7], [5, 3, 0]],
      [[0, 1], [5, 0]]]
# Reconfiguration cost for between configurations on each machine
RC = [[[0, 2], [4, 0]],
      [[0, 6, 8], [6, 0, 4], [2, 4, 0]],
      [[0, 6], [8, 0]]]

# Feasible operation sequences for part variants
qv = [[] for v in V]
for v in V:
    for item in itertools.permutations(VP[v]):
        for q in item:
            if K[v][q]:
                if not set(K[v][q]).issubset(set(
                        list(item)[:list(item).index(q)])):
                    break
        else:
            qv[v].append(list(item))

# Feasible machine and configuration pairs for each operation
mg = [[] for e in OP]
for e in OP:
    for m in M:
        for g in range(G[m]):
            if MG[e][m][g] == 1:
                mg[e].append((m, g))

# total operations
opn = 0
for i in I:
    for v in V:
        if J[i][v] != 0:
            for j in range(J[i][v]):
                opn = opn + len(VP[v])


# Define the decision variables, objective functions and constraints


class Solution:

    # Constraints
    def layout_check(self):
        self.tlc = LC[- 1] * (abs(self.x[- 1] - X[- 1]) +
                              abs(self.y[- 1] - Y[- 1]))
        for m in range(len(M) - 1):
            self.tlc = self.tlc + LC[m] * (abs(self.x[m] - X[m]) +
                                           abs(self.y[m] - Y[m]))
            for m_ in range(m + 1, len(M)):
                if abs(self.x[m_] - self.x[m]) < SX[m_] + SX[m]:
                    if abs(self.y[m_] - self.y[m]) < SY[m_] + SY[m]:
                        self.pf = 10000
                        self.tlc = self.pf
                        break
            else:
                continue
            break
        return self.pf, self.tlc

    def operation_check(self):
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        if tuple(self.rho[i][v][j]) not in qv[v]:
                            self.rho[i][v][j] = list(choice(qv[v]))
        return self.rho

    def machine_configuration_check(self):
        self.tpc = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v])):
                            if (self.alpha[i][v][j][q], self.phi[i][v][j][q]) \
                                    not in mg[self.rho[i][v][j][q]]:
                                (self.alpha[i][v][j][q], self.phi[i][v][j][q]) \
                                    = choice(mg[self.rho[i][v][j][q]])
                            self.tpc = self.tpc + PC[v][self.rho[i][v][j][q]][
                                self.alpha[i][v][j][q]][self.phi[i][v][j][q]]
        return self.alpha, self.phi, self.tpc

    def jd(self):
        # Calculate the distance between operations in the operation sequence
        # for each job
        self.tfc = 0
        self.delta.clear()
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v]) - 1):
                            self.delta[i][v][j][q] = \
                                abs(self.x[self.alpha[i][v][j][q + 1]] -
                                    self.x[self.alpha[i][v][j][q]]) + \
                                abs(self.y[self.alpha[i][v][j][q + 1]] -
                                    self.y[self.alpha[i][v][j][q]])
                            self.tfc = self.tfc + FC[v] * self.delta[i][v][j][q]
                else:
                    self.delta[i][v] = []
        return self.delta, self.tfc

    def beginning_time_check(self):
        rc = 0
        sc = 0
        self.trc = 0
        self.tsc = 0
        self.thc = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v]) - 1):
                            if self.beta[i][v][j][q + 1] < \
                                    self.beta[i][v][j][q] + \
                                    PT[v][self.rho[i][v][j][q]][
                                        self.alpha[i][v][j][q]][
                                        self.phi[i][v][j][q]] + \
                                    FT[v] * self.delta[i][v][j][q]:
                                self.beta[i][v][j][q + 1] = \
                                    self.beta[i][v][j][q] + \
                                    PT[v][self.rho[i][v][j][q]][
                                        self.alpha[i][v][j][q]][
                                        self.phi[i][v][j][q]] + \
                                    FT[v] * self.delta[i][v][j][q]
        mni = 0
        mnv = 0
        mnj = 0
        mnq = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        if self.beta[i][v][j][0] < self.beta[mni][mnv][mnj][0]:
                            mni = i
                            mnv = v
                            mnj = j
        cg = [- 1 for m in M]
        cv = [- 1 for m in M]
        ce = [- 1 for m in M]
        ct = [0 for m in M]
        cnt = 0
        fn = []
        while cnt < opn:
            fn.append([mni, mnv, mnj, mnq])
            if mnq != 0 and ct[self.alpha[mni][mnv][mnj][mnq]] != 0:
                if self.phi[mni][mnv][mnj][mnq] != \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    rt = RT[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                    rc = RC[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                else:
                    rt = 0
                    rc = 0
                if mnv == cv[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.rho[mni][mnv][mnj][mnq] == \
                        ce[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.phi[mni][mnv][mnj][mnq] == \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    st = 0
                    sc = 0
                else:
                    st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                    sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                bm = ct[self.alpha[mni][mnv][mnj][mnq]] + rt + st
                if self.alpha[mni][mnv][mnj][mnq - 1] == \
                        self.alpha[mni][mnv][mnj][mnq]:
                    self.beta[mni][mnv][mnj][mnq] = bm
                    ht = 0
                else:
                    bj = self.beta[mni][mnv][mnj][mnq - 1] + PT[mnv][
                        self.rho[mni][mnv][mnj][mnq - 1]][
                        self.alpha[mni][mnv][mnj][mnq - 1]][
                        self.phi[mni][mnv][mnj][mnq - 1]] + \
                         FT[mnv] * self.delta[mni][mnv][mnj][mnq - 1]
                    self.beta[mni][mnv][mnj][mnq] = max(bj, bm)
                    ht = self.beta[mni][mnv][mnj][mnq] - bj
            elif mnq == 0 and ct[self.alpha[mni][mnv][mnj][mnq]] != 0:
                if self.phi[mni][mnv][mnj][mnq] != \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    rt = RT[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                    rc = RC[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                else:
                    rt = 0
                    rc = 0
                if mnv == cv[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.rho[mni][mnv][mnj][mnq] == \
                        ce[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.phi[mni][mnv][mnj][mnq] == \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    st = 0
                    sc = 0
                else:
                    st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                    sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                self.beta[mni][mnv][mnj][mnq] = \
                    ct[self.alpha[mni][mnv][mnj][mnq]] + rt + st
                ht = 0
            elif mnq != 0 and ct[self.alpha[mni][mnv][mnj][mnq]] == 0:
                st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                bj = self.beta[mni][mnv][mnj][mnq - 1] + PT[mnv][
                    self.rho[mni][mnv][mnj][mnq - 1]][
                    self.alpha[mni][mnv][mnj][mnq - 1]][
                    self.phi[mni][mnv][mnj][mnq - 1]] + \
                     FT[mnv] * self.delta[mni][mnv][mnj][mnq - 1]
                self.beta[mni][mnv][mnj][mnq] = max(bj, st)
                ht = 0
            else:
                st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                self.beta[mni][mnv][mnj][mnq] = st
                ht = 0
            self.trc = self.trc + rc
            self.tsc = self.tsc + sc
            self.thc = self.thc + HC[mnv] * ht
            cv[self.alpha[mni][mnv][mnj][mnq]] = mnv
            ce[self.alpha[mni][mnv][mnj][mnq]] = self.rho[mni][mnv][mnj][mnq]
            cg[self.alpha[mni][mnv][mnj][mnq]] = self.phi[mni][mnv][mnj][mnq]
            ct[self.alpha[mni][mnv][mnj][mnq]] = \
                self.beta[mni][mnv][mnj][mnq] + \
                PT[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
            temp = - 1
            for i in I:
                for v in V:
                    if J[i][v] != 0:
                        for j in range(J[i][v]):
                            for q in range(len(VP[v])):
                                if [i, v, j, q] not in fn:
                                    if temp == -1:
                                        temp = self.beta[i][v][j][q]
                                        tpi = i
                                        tpv = v
                                        tpj = j
                                        tpq = q
                                    elif self.beta[i][v][j][q] < temp:
                                        temp = self.beta[i][v][j][q]
                                        tpi = i
                                        tpv = v
                                        tpj = j
                                        tpq = q
            mni = tpi
            mnv = tpv
            mnj = tpj
            mnq = tpq
            cnt = cnt + 1
        return self.beta, self.trc, self.tsc, self.thc

        # Objective functions
        # First objective function.

    def function1(self):
        # Calculate the tardiness for each product
        T = []
        for i in I:
            temp = []
            for v in V:
                if J[i][v] != 0:
                    temp.append(max(self.beta[i][v][j][- 1] +
                                    PT[v][self.rho[i][v][j][- 1]][
                                        self.alpha[i][v][j][- 1]][
                                        self.phi[i][v][j][- 1]]
                                    for j in range(J[i][v])))
                else:
                    temp.append(0)
            T.append(max(temp))
        # Calculate the penalty for tardiness
        value = sum(max(0, T[i] - D[i]) * W[i] for i in I)
        return value

        # Second objective function.

    def function2(self):
        self.f2 = self.tlc + self.tpc + self.tfc + self.trc + self.tsc + \
                  self.thc
        return self.f2

    def __init__(self):
        self.pf = 1
        self.x = list(X)
        self.y = list(Y)
        self.tlc = LC[- 1] * (abs(self.x[- 1] - X[- 1]) +
                              abs(self.y[- 1] - Y[- 1]))
        self.pf, self.tlc = self.layout_check()
        self.rho = [[[list(choice(qv[v]))
                      for j in range(J[i][v])] for v in V] for i in I]
        self.rho = self.operation_check()
        self.alpha = [[[[choice(M) for q in range(len(VP[v]))]
                        for j in range(J[i][v])] for v in V] for i in I]
        self.phi = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
                     for v in V] for i in I]
        self.tpc = 0
        self.alpha, self.phi, self.tpc = self.machine_configuration_check()
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        self.tfc = 0
        self.delta, self.tfc = self.jd()
        self.trc = 0
        self.tsc = 0
        self.thc = 0
        self.beta = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
                      for v in V] for i in I]
        self.beta, self.trc, self.tsc, self.thc = self.beginning_time_check()
        # Objective functions value
        self.f1 = self.function1() * self.pf
        self.f2 = self.function2() * self.pf


def domination_amount(a, b, r1, r2):
    if a.f1 != b.f1 and a.f2 != b.f2 and r1 != 0 and r2 != 0:
        dom = (abs(a.f1 - b.f1) / r1) * (abs(a.f2 - b.f2) / r2)
    elif a.f1 != b.f1 and a.f2 == b.f2:
        dom = abs(a.f1 - b.f1) / r1
    elif a.f1 == b.f1 and a.f2 != b.f2:
        dom = abs(a.f2 - b.f2) / r2
    return dom


def single_linkage_clustering(a):
    dst = []
    clt = []
    tmp_ahv = []
    for i in range(len(a)):
        clt.append([a[i]])
        tmp_ahv.append([a[i]])
    del_index = []
    for i in range(len(a) - 1):
        for j in range(i + 1, len(a)):
            dst.append(math.sqrt(
                abs(a[i].f1 - a[j].f1) ** 2 +
                abs(a[i].f2 - a[j].f2) ** 2))
    slc = linkage(dst, 'single')
    for i in range(len(a) - HL):
        new_clt = []
        new_clt.extend(clt[int(slc[i][0])])
        new_clt.extend(clt[int(slc[i][1])])
        clt.append(new_clt)
        tmp_ahv.append(new_clt)
        del_index.append(int(slc[i][0]))
        del_index.append(int(slc[i][1]))
    tmp_ahv = [tmp_ahv[i] for i in range(len(tmp_ahv))
               if i not in del_index]
    a = []
    for i in range(len(tmp_ahv)):
        if len(tmp_ahv[i]) == 1:
            a.extend(tmp_ahv[i])
        else:
            dj = []
            for j in range(len(tmp_ahv[i])):
                d = 0
                for j_ in range(len(tmp_ahv[i])):
                    d = d + math.sqrt(
                        abs(tmp_ahv[i][j_].f1 - tmp_ahv[i][j].f1) ** 2 +
                        abs(tmp_ahv[i][j_].f2 - tmp_ahv[i][j].f2) ** 2)
                dj.append(d)
            a.append(tmp_ahv[i][dj.index(min(dj))])
    return a


# Main program starts here
T_max = 100
T_min = 1
itr = 100
cooling_rate = 0.99
temp = T_max
HL = 11
SL = 20
# Initialize the Archive
init_ahv = []
init_slt = Solution()
init_ahv.append(init_slt)
while len(init_ahv) < 2:
    init_slt = Solution()
    if init_slt.f1 < init_ahv[0].f1 and init_slt.f2 > init_ahv[0].f2:
        init_ahv.append(init_slt)
    elif init_slt.f1 > init_ahv[0].f1 and init_slt.f2 < init_ahv[0].f2:
        init_ahv.append(init_slt)
    elif init_slt.f1 == init_ahv[0].f1 and init_slt.f2 == init_ahv[0].f2:
        if init_slt.x != init_ahv[0].x or init_slt.y != init_ahv[0].y or \
                init_slt.rho != init_ahv[0].rho or \
                init_slt.alpha != init_ahv[0].alpha or \
                init_slt.phi != init_ahv[0].phi or \
                init_slt.beta != init_ahv[0].beta:
            init_ahv.append(init_slt)
# Iteration
current_pt = copy.deepcopy(choice(init_ahv))
ahv = init_ahv
ahv_f1_max = max([ahv[i].f1 for i in range(len(ahv))])
ahv_f1_min = min([ahv[i].f1 for i in range(len(ahv))])
ahv_f2_max = max([ahv[i].f2 for i in range(len(ahv))])
ahv_f2_min = min([ahv[i].f2 for i in range(len(ahv))])
while temp > T_min:
    for i in range(itr):
        new_pt = Solution()
        new_loc = random.random()
        if new_loc < 1 / 5:
            new_m = choice(M)
            new_pt.x[new_m] = random.randint(SX[new_m], BX - SX[new_m])
            new_pt.y[new_m] = random.randint(SY[new_m], BY - SY[new_m])
        elif 1 / 5 <= new_loc < 2 / 5:
            new_i = choice(I)
            new_v = choice(V)
            while J[new_i][new_v] == 0:
                new_v = choice(V)
            new_j = random.randint(0, J[new_i][new_v] - 1)
            new_q = random.randint(0, len(VP[new_v]) - 1)
            new_pt.rho[new_i][new_v][new_j][new_q] = choice(VP[new_v])
        elif 2 / 5 <= new_loc < 3 / 5:
            new_i = choice(I)
            new_v = choice(V)
            while J[new_i][new_v] == 0:
                new_v = choice(V)
            new_j = random.randint(0, J[new_i][new_v] - 1)
            new_q = random.randint(0, len(VP[new_v]) - 1)
            new_pt.alpha[new_i][new_v][new_j][new_q] = choice(M)
        elif 3 / 5 <= new_loc < 4 / 5:
            new_i = choice(I)
            new_v = choice(V)
            while J[new_i][new_v] == 0:
                new_v = choice(V)
            new_j = random.randint(0, J[new_i][new_v] - 1)
            new_q = random.randint(0, len(VP[new_v]) - 1)
            new_pt.phi[new_i][new_v][new_j][new_q] = \
                random.randint(0, G[
                    new_pt.alpha[new_i][new_v][new_j][new_q]] - 1)
        else:
            new_i = choice(I)
            new_v = choice(V)
            while J[new_i][new_v] == 0:
                new_v = choice(V)
            new_j = random.randint(0, J[new_i][new_v] - 1)
            new_q = random.randint(0, len(VP[new_v]) - 1)
            new_pt.beta[new_i][new_v][new_j][new_q] = \
                random.randint(0, new_pt.beta[new_i][new_v][new_j][-1])
        new_pt.pf, new_pt.tlc = new_pt.layout_check()
        new_pt.rho = new_pt.operation_check()
        new_pt.alpha, new_pt.phi, new_pt.tpc = \
            new_pt.machine_configuration_check()
        new_pt.delta, new_pt.tfc = new_pt.jd()
        new_pt.beta, new_pt.trc, new_pt.tsc, new_pt.thc = \
            new_pt.beginning_time_check()
        new_pt.f1 = new_pt.function1() * new_pt.pf
        new_pt.f2 = new_pt.function2() * new_pt.pf
        if new_pt.pf != 1:
            continue
        R1 = max(ahv_f1_max, current_pt.f1, new_pt.f1) - min(
            ahv_f1_min, current_pt.f1, new_pt.f1)
        R2 = max(ahv_f2_max, current_pt.f2, new_pt.f2) - min(
            ahv_f2_min, current_pt.f2, new_pt.f2)
        if (current_pt.f1 < new_pt.f1 and current_pt.f2 < new_pt.f2) or \
                (current_pt.f1 < new_pt.f1 and current_pt.f2 == new_pt.f2) or \
                (current_pt.f1 == new_pt.f1 and current_pt.f2 < new_pt.f2):
            dom_ttl = 0
            k = 0
            for j in range(len(ahv)):
                if (ahv[j].f1 < new_pt.f1 and ahv[j].f2 < new_pt.f2) or \
                        (ahv[j].f1 < new_pt.f1 and ahv[j].f2 == new_pt.f2) or \
                        (ahv[j].f1 == new_pt.f1 and ahv[j].f2 < new_pt.f2):
                    dom_ttl = dom_ttl + \
                              domination_amount(ahv[j], new_pt, R1, R2)
                    k = k + 1
            dom_avg = (dom_ttl +
                       domination_amount(current_pt, new_pt, R1, R2)) / (k + 1)
            prob = 1 / (1 + np.exp(dom_avg * temp))
            apt_prb = random.random()
            if apt_prb <= prob:
                current_pt = new_pt
        elif (current_pt.f1 < new_pt.f1 and current_pt.f2 > new_pt.f2) or \
                (current_pt.f1 > new_pt.f1 and current_pt.f2 < new_pt.f2):
            k1 = 0
            k2 = 0
            k3 = 0
            dom_ttl = 0
            del_list = []
            for j in range(len(ahv)):
                if (ahv[j].f1 < new_pt.f1 and ahv[j].f2 < new_pt.f2) or \
                        (ahv[j].f1 < new_pt.f1 and ahv[j].f2 == new_pt.f2) or \
                        (ahv[j].f1 == new_pt.f1 and ahv[j].f2 < new_pt.f2):
                    k1 = k1 + 1
                    dom_ttl = dom_ttl + \
                              domination_amount(ahv[j], new_pt, R1, R2)
                elif (ahv[j].f1 < new_pt.f1 and ahv[j].f2 > new_pt.f2) or \
                        (ahv[j].f1 > new_pt.f1 and ahv[j].f2 < new_pt.f2):
                    k2 = k2 + 1
                elif (new_pt.f1 < ahv[j].f1 and new_pt.f2 < ahv[j].f2) or \
                        (new_pt.f1 < ahv[j].f1 and new_pt.f2 == ahv[j].f2) or \
                        (new_pt.f1 == ahv[j].f1 and new_pt.f2 < ahv[j].f2):
                    k3 = k3 + 1
                    del_list.append(j)
            if k1 >= 1:
                dom_avg = dom_ttl / k1
                prob = 1 / (1 + np.exp(dom_avg * temp))
                apt_prb = random.random()
                if apt_prb <= prob:
                    current_pt = new_pt
            elif k2 == len(ahv):
                current_pt = new_pt
                if new_pt.pf == 1:
                    ahv.append(new_pt)
                    if len(ahv) > SL:
                        single_linkage_clustering(ahv)
            elif k3 >= 1:
                current_pt = new_pt
                ahv = [ahv[j] for j in range(len(ahv)) if j not in del_list]
        elif (new_pt.f1 < current_pt.f1 and new_pt.f2 < current_pt.f2) or \
                (new_pt.f1 < current_pt.f1 and new_pt.f2 == current_pt.f2) or \
                (new_pt.f1 == current_pt.f1 and new_pt.f2 < current_pt.f2):
            k1 = 0
            k2 = 0
            k3 = 0
            dom_min = 0
            del_list = []
            for j in range(len(ahv)):
                if (ahv[j].f1 < new_pt.f1 and ahv[j].f2 < new_pt.f2) or \
                        (ahv[j].f1 < new_pt.f1 and ahv[j].f2 == new_pt.f2) or \
                        (ahv[j].f1 == new_pt.f1 and ahv[j].f2 < new_pt.f2):
                    k1 = k1 + 1
                    if k1 == 1 or dom_min > domination_amount(ahv[j], new_pt,
                                                              R1, R2):
                        dom_min = domination_amount(ahv[j], new_pt, R1, R2)
                elif (ahv[j].f1 < new_pt.f1 and ahv[j].f2 > new_pt.f2) or \
                        (ahv[j].f1 > new_pt.f1 and ahv[j].f2 < new_pt.f2):
                    k2 = k2 + 1
                elif (new_pt.f1 < ahv[j].f1 and new_pt.f2 < ahv[j].f2) or \
                        (new_pt.f1 < ahv[j].f1 and new_pt.f2 == ahv[j].f2) or \
                        (new_pt.f1 == ahv[j].f1 and new_pt.f2 < ahv[j].f2):
                    k3 = k3 + 1
                    del_list.append(j)
            if k1 >= 1:
                prob = 1 / (1 + math.exp(- dom_min))
                if apt_prb <= prob:
                    current_pt = new_pt
            elif k2 == len(ahv):
                if current_pt in ahv:
                    ahv.remove(current_pt)
                current_pt = new_pt
                if new_pt.pf == 1:
                    ahv.append(new_pt)
                    if len(ahv) > SL:
                        single_linkage_clustering(ahv)
            elif k3 >= 1:
                current_pt = new_pt
                ahv = [ahv[j] for j in range(len(ahv)) if j not in del_list]
    temp = cooling_rate * temp
if len(ahv) > SL:
    single_linkage_clustering(ahv)
for i in range(len(ahv)):
    print(ahv[i].f1, ahv[i].f2)
    print(ahv[i].x, ahv[i].y)
    print(ahv[i].rho)
    print(ahv[i].alpha)
    print(ahv[i].phi)
    print(ahv[i].beta)
    print('')
p1 = time.process_time()
print(p1 - p0)
