import random
from random import choice
import numpy as np
import itertools
import copy
import time

p0 = time.process_time()

# Parameters

# Parameters for products
# Set of products
I = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Due date for each product
D = [100, 150, 200, 250, 300, 350, 300, 250, 200, 400]
# Penalty of unit time tardiness for each product
W = [2, 1, 4, 5, 3, 9, 6, 8, 7, 10]

# Parameters for operations
# Set of operations
OP = [0, 1, 2, 3, 4]
MG = [[[1, 0], [1, 0, 0], [1, 0]],
      [[0, 1], [0, 1, 0], [0, 1]],
      [[1, 0], [0, 0, 1], [0, 1]],
      [[0, 1], [0, 1, 0], [1, 0]],
      [[0, 0], [1, 0, 1], [0, 0]]]

# Parameters for part variants
V = [0, 1, 2]  # Set of part variants
# Transfer time for moving a WIP belonging to each part variant in unit distance
FT = [1, 3, 5]
# Transfer cost for moving a WIP belonging to each part variant in unit distance
FC = [2, 4, 6]
# Holding cost for holding a WIP belonging to each part variant in unit time
HC = [0.5, 0.6, 0.4]
# Set of operations for each part variant
VP = [[0, 1, 2, 3, 4],
      [0, 1, 2, 3, 4],
      [0, 1, 2, 4]]

# Parameters for part variants-operations
K = [[[], [0], [0], [1], [1, 2]],
     [[], [], [0], [1, 2], [3]],
     [[], [0], [0], [], [0]]]
PT = [[[[3, 0], [5, 0, 0], [4, 0]],
       [[0, 8], [0, 5, 0], [0, 7]],
       [[1, 0], [0, 0, 2], [0, 3]],
       [[0, 9], [0, 7, 0], [6, 0]],
       [[0, 0], [2, 0, 1], [0, 0]]],
      [[[5, 0], [4, 0, 0], [6, 0]],
       [[0, 6], [0, 7, 0], [0, 8]],
       [[9, 0], [0, 0, 7], [0, 8]],
       [[0, 5], [0, 3, 0], [2, 0]],
       [[0, 0], [2, 0, 4], [0, 0]]],
      [[[5, 0], [2, 0, 0], [3, 0]],
       [[0, 9], [0, 9, 0], [0, 8]],
       [[4, 0], [0, 0, 2], [0, 5]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [7, 0, 6], [0, 0]]]]
PC = [[[[5, 0], [8, 0, 0], [6, 0]],
       [[0, 8], [0, 4, 0], [0, 6]],
       [[8, 0], [0, 0, 5], [0, 6]],
       [[0, 4], [0, 6, 0], [6, 0]],
       [[0, 0], [5, 0, 7], [0, 0]]],
      [[[6, 0], [8, 0, 0], [7, 0]],
       [[0, 4], [0, 9, 0], [0, 7]],
       [[6, 0], [0, 0, 4], [0, 3]],
       [[0, 7], [0, 4, 0], [8, 0]],
       [[0, 0], [4, 0, 5], [0, 0]]],
      [[[5, 0], [4, 0, 0], [7, 0]],
       [[0, 4], [0, 6, 0], [0, 4]],
       [[5, 0], [0, 0, 3], [0, 4]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [6, 0, 4], [0, 0]]]]
ST = [[[[5, 0], [4, 0, 0], [2, 0]],
       [[0, 5], [0, 6, 0], [0, 7]],
       [[8, 0], [0, 0, 9], [0, 8]],
       [[0, 4], [0, 2, 0], [3, 0]],
       [[0, 0], [6, 0, 8], [0, 0]]],
      [[[7, 0], [5, 0, 0], [6, 0]],
       [[0, 7], [0, 5, 0], [0, 4]],
       [[8, 0], [0, 0, 5], [0, 7]],
       [[0, 6], [0, 4, 0], [3, 0]],
       [[0, 0], [4, 0, 3], [0, 0]]],
      [[[3, 0], [1, 0, 0], [1, 0]],
       [[0, 4], [0, 3, 0], [0, 2]],
       [[6, 0], [0, 0, 3], [0, 5]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [8, 0, 6], [0, 0]]]]
SC = [[[[8, 0], [7, 0, 0], [9, 0]],
       [[0, 4], [0, 5, 0], [0, 3]],
       [[2, 0], [0, 0, 2], [0, 1]],
       [[0, 6], [0, 7, 0], [5, 0]],
       [[0, 0], [5, 0, 4], [0, 0]]],
      [[[8, 0], [6, 0, 0], [6, 0]],
       [[0, 6], [0, 4, 0], [0, 7]],
       [[5, 0], [0, 0, 4], [0, 3]],
       [[0, 6], [0, 8, 0], [7, 0]],
       [[0, 0], [4, 0, 8], [0, 0]]],
      [[[5, 0], [6, 0, 0], [5, 0]],
       [[0, 8], [0, 5, 0], [0, 6]],
       [[5, 0], [0, 0, 3], [0, 2]],
       [[0, 0], [0, 0, 0], [0, 0]],
       [[0, 0], [5, 0, 7], [0, 0]]]]

# Parameters for products-part variants
J = [[1, 1, 0],
     [1, 0, 1],
     [0, 1, 1],
     [2, 1, 0],
     [0, 2, 1],
     [2, 0, 1],
     [1, 1, 1],
     [1, 2, 0],
     [1, 0, 2],
     [0, 1, 2]]  # Number of each part variant in each product

# Parameters for workshop
BX = 12
BY = 9

# Parameters for machines
M = [0, 1, 2]  # Number of machines
LC = [1, 2, 3]  # Layout cost for moving each machine in unit distance
X = [2, 8, 6]  # Initial location for each machine on the X-coordinate
Y = [7, 3, 8]  # Initial location for each machine on the Y-coordinate
SX = [1, 3, 2]  # Security distance for each machine on the X-coordinate
SY = [1, 2, 1]  # Security distance for each machine on the Y-coordinate

# Parameters for configurations
G = [2, 3, 2]  # Number of configurations on each machine
# Reconfiguration time for between configurations on each machine
RT = [[[0, 1], [3, 0]],
      [[0, 5, 7], [9, 0, 7], [5, 3, 0]],
      [[0, 1], [5, 0]]]
# Reconfiguration cost for between configurations on each machine
RC = [[[0, 2], [4, 0]],
      [[0, 6, 8], [6, 0, 4], [2, 4, 0]],
      [[0, 6], [8, 0]]]

# Feasible operation sequences for part variants
qv = [[] for v in V]
for v in V:
    for item in itertools.permutations(VP[v]):
        for q in item:
            if K[v][q]:
                if not set(K[v][q]).issubset(set(
                        list(item)[:list(item).index(q)])):
                    break
        else:
            qv[v].append(item)

# Feasible machine and configuration pairs for each operation
mg = [[] for e in OP]
for e in OP:
    for m in M:
        for g in range(G[m]):
            if MG[e][m][g] == 1:
                mg[e].append((m, g))

# total operations
opn = 0
for i in I:
    for v in V:
        if J[i][v] != 0:
            for j in range(J[i][v]):
                opn = opn + len(VP[v])


# Define the decision variables, objective functions and constraints


class Individual:

    # Constraints
    def layout_check(self):
        self.pf = 1
        self.tlc = LC[- 1] * (abs(self.x[- 1] - X[- 1]) +
                              abs(self.y[- 1] - Y[- 1]))
        for m in range(len(M) - 1):
            self.tlc = self.tlc + LC[m] * (abs(self.x[m] - X[m]) +
                                           abs(self.y[m] - Y[m]))
            for m_ in range(m + 1, len(M)):
                if abs(self.x[m_] - self.x[m]) < SX[m_] + SX[m]:
                    if abs(self.y[m_] - self.y[m]) < SY[m_] + SY[m]:
                        self.pf = 10000
                        self.tlc = self.tlc + self.pf
                        break
            else:
                continue
            break
        return self.pf, self.tlc

    def operation_check(self):
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        if tuple(self.rho[i][v][j]) not in qv[v]:
                            self.rho[i][v][j] = list(choice(qv[v]))
        return self.rho

    def machine_configuration_check(self):
        self.tpc = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v])):
                            if (self.alpha[i][v][j][q], self.phi[i][v][j][q]) \
                                    not in mg[self.rho[i][v][j][q]]:
                                (self.alpha[i][v][j][q], self.phi[i][v][j][q]) \
                                    = choice(mg[self.rho[i][v][j][q]])
                            self.tpc = self.tpc + PC[v][self.rho[i][v][j][q]][
                                self.alpha[i][v][j][q]][self.phi[i][v][j][q]]
        return self.alpha, self.phi, self.tpc

    def jd(self):
        # Calculate the distance between operations in the operation sequence
        # for each job
        self.tfc = 0
        self.delta.clear()
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v]) - 1):
                            self.delta[i][v][j][q] = \
                                abs(self.x[self.alpha[i][v][j][q + 1]] -
                                    self.x[self.alpha[i][v][j][q]]) + \
                                abs(self.y[self.alpha[i][v][j][q + 1]] -
                                    self.y[self.alpha[i][v][j][q]])
                            self.tfc = self.tfc + FC[v] * self.delta[i][v][j][q]
                else:
                    self.delta[i][v] = []
        return self.delta, self.tfc

    def beginning_time_check(self):
        rc = 0
        sc = 0
        self.trc = 0
        self.tsc = 0
        self.thc = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v]) - 1):
                            if self.beta[i][v][j][q + 1] < \
                                    self.beta[i][v][j][q] + \
                                    PT[v][self.rho[i][v][j][q]][
                                        self.alpha[i][v][j][q]][
                                        self.phi[i][v][j][q]] + \
                                    FT[v] * self.delta[i][v][j][q]:
                                self.beta[i][v][j][q + 1] = \
                                    self.beta[i][v][j][q] + \
                                    PT[v][self.rho[i][v][j][q]][
                                        self.alpha[i][v][j][q]][
                                        self.phi[i][v][j][q]] + \
                                    FT[v] * self.delta[i][v][j][q]
        mni = 0
        mnv = 0
        mnj = 0
        mnq = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        if self.beta[i][v][j][0] < self.beta[mni][mnv][mnj][0]:
                            mni = i
                            mnv = v
                            mnj = j
        cg = [- 1 for m in M]
        cv = [- 1 for m in M]
        ce = [- 1 for m in M]
        ct = [0 for m in M]
        cnt = 0
        fn = []
        while cnt < opn:
            fn.append([mni, mnv, mnj, mnq])
            if mnq != 0 and ct[self.alpha[mni][mnv][mnj][mnq]] != 0:
                if self.phi[mni][mnv][mnj][mnq] != \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    rt = RT[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                    rc = RC[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                else:
                    rt = 0
                    rc = 0
                if mnv == cv[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.rho[mni][mnv][mnj][mnq] == \
                        ce[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.phi[mni][mnv][mnj][mnq] == \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    st = 0
                    sc = 0
                else:
                    st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                    sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                bm = ct[self.alpha[mni][mnv][mnj][mnq]] + rt + st
                if self.alpha[mni][mnv][mnj][mnq - 1] == \
                        self.alpha[mni][mnv][mnj][mnq]:
                    self.beta[mni][mnv][mnj][mnq] = bm
                    ht = 0
                else:
                    bj = self.beta[mni][mnv][mnj][mnq - 1] + PT[mnv][
                        self.rho[mni][mnv][mnj][mnq - 1]][
                        self.alpha[mni][mnv][mnj][mnq - 1]][
                        self.phi[mni][mnv][mnj][mnq - 1]] + \
                         FT[mnv] * self.delta[mni][mnv][mnj][mnq - 1]
                    self.beta[mni][mnv][mnj][mnq] = max(bj, bm)
                    ht = self.beta[mni][mnv][mnj][mnq] - bj
            elif mnq == 0 and ct[self.alpha[mni][mnv][mnj][mnq]] != 0:
                if self.phi[mni][mnv][mnj][mnq] != \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    rt = RT[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                    rc = RC[self.alpha[mni][mnv][mnj][mnq]][
                        cg[self.alpha[mni][mnv][mnj][mnq]]][
                        self.phi[mni][mnv][mnj][mnq]]
                else:
                    rt = 0
                    rc = 0
                if mnv == cv[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.rho[mni][mnv][mnj][mnq] == \
                        ce[self.alpha[mni][mnv][mnj][mnq]] and \
                        self.phi[mni][mnv][mnj][mnq] == \
                        cg[self.alpha[mni][mnv][mnj][mnq]]:
                    st = 0
                    sc = 0
                else:
                    st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                    sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                        self.alpha[mni][mnv][mnj][mnq]][
                        self.phi[mni][mnv][mnj][mnq]]
                self.beta[mni][mnv][mnj][mnq] = \
                    ct[self.alpha[mni][mnv][mnj][mnq]] + rt + st
                ht = 0
            elif mnq != 0 and ct[self.alpha[mni][mnv][mnj][mnq]] == 0:
                st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                bj = self.beta[mni][mnv][mnj][mnq - 1] + PT[mnv][
                    self.rho[mni][mnv][mnj][mnq - 1]][
                    self.alpha[mni][mnv][mnj][mnq - 1]][
                    self.phi[mni][mnv][mnj][mnq - 1]] + \
                     FT[mnv] * self.delta[mni][mnv][mnj][mnq - 1]
                self.beta[mni][mnv][mnj][mnq] = max(bj, st)
                ht = 0
            else:
                st = ST[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                sc = SC[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
                self.beta[mni][mnv][mnj][mnq] = st
                ht = 0
            self.trc = self.trc + rc
            self.tsc = self.tsc + sc
            self.thc = self.thc + HC[mnv] * ht
            cv[self.alpha[mni][mnv][mnj][mnq]] = mnv
            ce[self.alpha[mni][mnv][mnj][mnq]] = self.rho[mni][mnv][mnj][mnq]
            cg[self.alpha[mni][mnv][mnj][mnq]] = self.phi[mni][mnv][mnj][mnq]
            ct[self.alpha[mni][mnv][mnj][mnq]] = \
                self.beta[mni][mnv][mnj][mnq] + \
                PT[mnv][self.rho[mni][mnv][mnj][mnq]][
                    self.alpha[mni][mnv][mnj][mnq]][
                    self.phi[mni][mnv][mnj][mnq]]
            temp = - 1
            for i in I:
                for v in V:
                    if J[i][v] != 0:
                        for j in range(J[i][v]):
                            for q in range(len(VP[v])):
                                if [i, v, j, q] not in fn:
                                    if temp == -1:
                                        temp = self.beta[i][v][j][q]
                                        tpi = i
                                        tpv = v
                                        tpj = j
                                        tpq = q
                                    elif self.beta[i][v][j][q] < temp:
                                        temp = self.beta[i][v][j][q]
                                        tpi = i
                                        tpv = v
                                        tpj = j
                                        tpq = q
            mni = tpi
            mnv = tpv
            mnj = tpj
            mnq = tpq
            cnt = cnt + 1
        return self.beta, self.trc, self.tsc, self.thc

        # Objective functions
        # First objective function.

    def function1(self):
        # Calculate the tardiness for each product
        T = []
        for i in I:
            temp = []
            for v in V:
                if J[i][v] != 0:
                    temp.append(max(self.beta[i][v][j][- 1] +
                                    PT[v][self.rho[i][v][j][- 1]][
                                        self.alpha[i][v][j][- 1]][
                                        self.phi[i][v][j][- 1]]
                                    for j in range(J[i][v])))
                else:
                    temp.append(0)
            T.append(max(temp))
        # Calculate the penalty for tardiness
        value = sum(max(0, T[i] - D[i]) * W[i] for i in I)
        return value

        # Second objective function.

    def function2(self):
        self.f2 = self.tlc + self.tpc + self.tfc + self.trc + self.tsc + \
                  self.thc
        return self.f2

    def __init__(self):
        self.pf = 1
        self.x = [random.randint(SX[m], BX - SX[m]) for m in M]
        self.y = [random.randint(SY[m], BY - SY[m]) for m in M]
        self.tlc = LC[- 1] * (abs(self.x[- 1] - X[- 1]) +
                              abs(self.y[- 1] - Y[- 1]))
        self.pf, self.tlc = self.layout_check()
        self.rho = [[[list(choice(qv[v]))
                      for j in range(J[i][v])] for v in V] for i in I]
        self.rho = self.operation_check()
        self.alpha = [[[[choice(M) for q in range(len(VP[v]))]
                        for j in range(J[i][v])] for v in V] for i in I]
        self.phi = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
                     for v in V] for i in I]
        self.tpc = 0
        self.alpha, self.phi, self.tpc = self.machine_configuration_check()
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        self.tfc = 0
        self.delta, self.tfc = self.jd()
        self.trc = 0
        self.tsc = 0
        self.thc = 0
        self.beta = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
                      for v in V] for i in I]
        self.beta, self.trc, self.tsc, self.thc = self.beginning_time_check()
        # Objective functions value
        self.f1 = self.function1() * self.pf
        self.f2 = self.function2() * self.pf


class Population:
    size = 40
    parent = [[], []]
    F = []
    V1 = []
    V2 = []
    dr = []
    slc = []
    cso = []
    mut = []
    cd = [[] for i in range(len(dr))]
    ds = [[] for i in range(len(F))]

    def __init__(self):
        for l in range(self.size):
            prt = Individual()
            self.parent[0].append(prt)

    def elitist(self):
        self.F.clear()
        self.V1.clear()
        self.V2.clear()
        if not self.parent[1]:
            self.F.extend(self.parent[0])
        else:
            self.F.extend(self.parent[0])
            self.F.extend(self.parent[1])
        for i in range(len(self.F)):
            self.V1.append(self.F[i].f1)
            self.V2.append(self.F[i].f2)

    def fast_non_dominated_sort(self):
        self.elitist()
        self.ds = [[] for i in range(len(self.F))]
        self.dr.clear()
        v1 = copy.deepcopy(self.V1)
        v2 = copy.deepcopy(self.V2)
        for v in range(len(self.F)):
            for u in range(v + 1, len(self.F)):
                if v1[u] < v1[v] and v2[u] < v2[v] or v1[u] == v1[v] and \
                        v2[u] < v2[v] or v1[u] < v1[v] and v2[u] == v2[v]:
                    self.ds[v].append(u)
                elif v1[v] < v1[u] and v2[v] < v2[u] or v1[v] == v1[u] and \
                        v2[v] < v2[u] or v1[v] < v1[u] and v2[v] == v2[u]:
                    self.ds[u].append(v)
        ds = copy.deepcopy(self.ds)
        while ds != [[- 1]] * len(self.F):
            dr = []
            for v in range(len(self.F)):
                if not ds[v]:
                    dr.append(v)
                    ds[v].append(- 1)
            for u in range(len(self.F)):
                for v in dr:
                    if v in ds[u]:
                        ds[u].remove(v)
            self.dr.append(dr)

    def crowding_distance(self):
        self.fast_non_dominated_sort()
        self.cd = [[1.0 for j in range(len(self.dr[i]))] for i in
                   range(len(self.dr))]
        drv1 = [[self.V1[self.dr[i][j]] for j in range(len(self.dr[i]))]
                for i in range(len(self.dr))]
        drv2 = [[self.V2[self.dr[i][j]] for j in range(len(self.dr[i]))]
                for i in range(len(self.dr))]
        for i in range(len(self.dr)):
            array1 = np.array(drv1[i])
            array2 = np.array(drv2[i])
            a_s1 = sorted(array1)
            a_s2 = sorted(array2)
            a_i1 = np.argsort(array1)
            a_i2 = np.argsort(array2)
            if a_s1[0] != a_s1[- 1]:
                for j in range(1, len(self.dr[i]) - 1):
                    self.cd[i][a_i1[j]] = (a_s1[j + 1] - a_s1[j - 1]) / (
                            a_s1[- 1] - a_s1[0])
            if a_s2[0] != a_s2[- 1]:
                for j in range(1, len(self.dr[i]) - 1):
                    self.cd[i][a_i2[j]] = self.cd[i][a_i2[j]] + (
                            a_s2[j + 1] - a_s2[j - 1]) / (
                                                  a_s2[- 1] - a_s2[0])

    def selection(self):
        self.slc.clear()
        self.crowding_distance()
        num_solution = 0
        for i in range(len(self.dr)):
            a_cd = np.array(self.cd[i])
            a_cdi = np.argsort(a_cd)
            if num_solution + len(self.dr[i]) <= self.size:
                for j in range(len(self.dr[i])):
                    self.slc.append(self.F[self.dr[i][a_cdi[- j - 1]]])
                num_solution = num_solution + len(self.dr[i])
            else:
                for j in range(self.size - num_solution):
                    self.slc.append(self.F[self.dr[i][a_cdi[- j - 1]]])
                break

    def crossover(self):
        self.cso.clear()
        self.selection()
        pair = random.sample(range(self.size), self.size)
        self.cso.extend(self.slc[0:self.size // 2])
        for l in range(self.size // 2):
            new_cso = copy.deepcopy(self.slc[pair[l + self.size // 2]])
            for m in M:
                new_cso.x[m] = (self.slc[pair[l]].x[m] +
                                self.slc[pair[l + self.size // 2]].x[m]) // 2
                new_cso.y[m] = (self.slc[pair[l]].y[m] +
                                self.slc[pair[l + self.size // 2]].y[m]) // 2
            for i in I:
                for v in V:
                    if J[i][v] != 0:
                        for j in range(J[i][v]):
                            for q in range(1, len(VP[v])):
                                new_cso.rho[i][v][j][q] = \
                                    (self.slc[pair[l]].rho[i][v][j][q] +
                                     self.slc[pair[l + self.size // 2]].rho[
                                         i][v][j][q]) // 2
                                new_cso.alpha[i][v][j][q] = \
                                    (self.slc[pair[l]].alpha[i][v][j][q] +
                                     self.slc[pair[l + self.size // 2]].alpha[
                                         i][v][j][q]) // 2
                                new_cso.phi[i][v][j][q] = \
                                    (self.slc[pair[l]].phi[i][v][j][q] +
                                     self.slc[pair[l + self.size // 2]].phi[
                                         i][v][j][q]) // 2
                                new_cso.beta[i][v][j][q] = \
                                    (self.slc[pair[l]].beta[i][v][j][q] +
                                     self.slc[pair[l + self.size // 2]].beta[
                                         i][v][j][q]) // 2
            new_cso.pf, new_cso.tlc = new_cso.layout_check()
            new_cso.rho = new_cso.operation_check()
            new_cso.alpha, new_cso.phi, new_cso.tpc = \
                new_cso.machine_configuration_check()
            new_cso.delta, new_cso.tfc = new_cso.jd()
            new_cso.beta, new_cso.trc, new_cso.tsc, new_cso.thc = \
                new_cso.beginning_time_check()
            new_cso.f1 = new_cso.function1() * new_cso.pf
            new_cso.f2 = new_cso.function2() * new_cso.pf
            self.cso.append(new_cso)

    def mutation(self):
        self.mut.clear()
        self.crossover()
        for l in range(len(self.cso)):
            mutation_prob = random.random()
            if mutation_prob < 0.1:
                new_mut = copy.deepcopy(self.cso[l])
                mutation_loc = random.random()
                if mutation_loc < 1 / 5:
                    mut_m = choice(M)
                    new_mut.x[mut_m] = random.randint(SX[mut_m], BX - SX[mut_m])
                    new_mut.y[mut_m] = random.randint(SY[mut_m], BY - SY[mut_m])
                elif 1 / 5 <= mutation_loc < 2 / 5:
                    mut_i = choice(I)
                    mut_v = choice(V)
                    while J[mut_i][mut_v] == 0:
                        mut_v = choice(V)
                    mut_j = random.randint(0, J[mut_i][mut_v] - 1)
                    mut_q = random.randint(0, len(VP[mut_v]) - 1)
                    new_mut.rho[mut_i][mut_v][mut_j][mut_q] = choice(VP[mut_v])
                elif 2 / 5 <= mutation_loc < 3 / 5:
                    mut_i = choice(I)
                    mut_v = choice(V)
                    while J[mut_i][mut_v] == 0:
                        mut_v = choice(V)
                    mut_j = random.randint(0, J[mut_i][mut_v] - 1)
                    mut_q = random.randint(0, len(VP[mut_v]) - 1)
                    new_mut.alpha[mut_i][mut_v][mut_j][mut_q] = choice(M)
                elif 3 / 5 <= mutation_loc < 4 / 5:
                    mut_i = choice(I)
                    mut_v = choice(V)
                    while J[mut_i][mut_v] == 0:
                        mut_v = choice(V)
                    mut_j = random.randint(0, J[mut_i][mut_v] - 1)
                    mut_q = random.randint(0, len(VP[mut_v]) - 1)
                    new_mut.phi[mut_i][mut_v][mut_j][mut_q] = \
                        random.randint(0, G[
                            new_mut.alpha[mut_i][mut_v][mut_j][mut_q]] - 1)
                else:
                    mut_i = choice(I)
                    mut_v = choice(V)
                    while J[mut_i][mut_v] == 0:
                        mut_v = choice(V)
                    mut_j = random.randint(0, J[mut_i][mut_v] - 1)
                    mut_q = random.randint(0, len(VP[mut_v]) - 1)
                    new_mut.beta[mut_i][mut_v][mut_j][mut_q] = \
                        random.randint(0, new_mut.beta[mut_i][mut_v][mut_j][-1])
                new_mut.pf, new_mut.tlc = new_mut.layout_check()
                new_mut.rho = new_mut.operation_check()
                new_mut.alpha, new_mut.phi, new_mut.tpc = \
                    new_mut.machine_configuration_check()
                new_mut.delta, new_mut.tfc = new_mut.jd()
                new_mut.beta, new_mut.trc, new_mut.tsc, new_mut.thc = \
                    new_mut.beginning_time_check()
                new_mut.f1 = new_mut.function1() * new_mut.pf
                new_mut.f2 = new_mut.function2() * new_mut.pf
                self.mut.append(new_mut)
            else:
                self.mut.append(self.cso[l])


# Main program starts here
plt_gen = Population()
plt_gen.fast_non_dominated_sort()
opt = []
opt_dup = []
for v in range(len(plt_gen.dr[0]) - 1):
    for u in range(v + 1, len(plt_gen.dr[0])):
        if plt_gen.F[plt_gen.dr[0][u]].f1 == plt_gen.F[plt_gen.dr[0][v]].f1 \
                and plt_gen.F[plt_gen.dr[0][u]].f2 == plt_gen.F[
            plt_gen.dr[0][v]].f2:
            if plt_gen.F[plt_gen.dr[0][u]].x == plt_gen.F[plt_gen.dr[0][v]].x \
                    and plt_gen.F[plt_gen.dr[0][u]].y == plt_gen.F[
                plt_gen.dr[0][v]].y:
                if plt_gen.F[plt_gen.dr[0][u]].rho == \
                        plt_gen.F[plt_gen.dr[0][v]].rho and \
                        plt_gen.F[plt_gen.dr[0][u]].alpha == \
                        plt_gen.F[plt_gen.dr[0][v]].alpha and \
                        plt_gen.F[plt_gen.dr[0][u]].phi == \
                        plt_gen.F[plt_gen.dr[0][v]].phi and \
                        plt_gen.F[plt_gen.dr[0][u]].beta == \
                        plt_gen.F[plt_gen.dr[0][v]].beta:
                    opt_dup.append(u)
for i in range(len(plt_gen.dr[0])):
    if plt_gen.F[plt_gen.dr[0][i]].pf == 1:
        if i not in opt_dup:
            opt.append(plt_gen.F[plt_gen.dr[0][i]])
current_gen = 0
gen_limit = 1000
opt_elitist = []
opt_ndp = []
while current_gen < gen_limit:
    plt_gen.mutation()
    if current_gen > 0:
        plt_gen.parent[0] = copy.deepcopy(plt_gen.parent[1])
    plt_gen.parent[1] = copy.deepcopy(plt_gen.mut)
    opt_elitist = opt + plt_gen.parent[1]
    opt_dup.clear()
    for v in range(len(opt_elitist) - 1):
        for u in range(v + 1, len(opt_elitist)):
            if opt_elitist[u].f1 == opt_elitist[v].f1 and \
                    opt_elitist[u].f2 == opt_elitist[v].f2:
                if opt_elitist[u].x == opt_elitist[v].x and \
                        opt_elitist[u].y == opt_elitist[v].y:
                    if opt_elitist[u].rho == opt_elitist[v].rho and \
                            opt_elitist[u].alpha == opt_elitist[v].alpha and \
                            opt_elitist[u].phi == opt_elitist[v].phi and \
                            opt_elitist[u].beta == opt_elitist[v].beta:
                        opt_dup.append(u)
    opt_ndp.clear()
    for i in range(len(opt_elitist)):
        if opt_elitist[i].pf == 1:
            if i not in opt_dup:
                opt_ndp.append(opt_elitist[i])
    nds = [1 for i in range(len(opt_ndp))]
    nv1 = [opt_ndp[i].f1 for i in range(len(opt_ndp))]
    nv2 = [opt_ndp[i].f2 for i in range(len(opt_ndp))]
    for v in range(len(opt_ndp) - 1):
        if nds[v] == 0:
            continue
        for u in range(v, len(opt_ndp)):
            if nds[u] == 0:
                continue
            if nv1[u] < nv1[v] and nv2[u] < nv2[v] or nv1[u] == nv1[v] and \
                    nv2[u] < nv2[v] or nv1[u] < nv1[v] and nv2[u] == nv2[v]:
                nds[v] = 0
            elif nv1[v] < nv1[u] and nv2[v] < nv2[u] or nv1[v] == nv1[u] and \
                    nv2[v] < nv2[u] or nv1[v] < nv1[u] and nv2[v] == nv2[u]:
                nds[u] = 0
    opt.clear()
    for v in range(len(opt_ndp)):
        if nds[v] == 1:
            opt.append(opt_ndp[v])
    current_gen = current_gen + 1
for j in range(len(opt)):
    print(opt[j].f1, opt[j].f2)
    print(opt[j].x, opt[j].y)
    print(opt[j].rho)
    print(opt[j].alpha)
    print(opt[j].phi)
    print(opt[j].beta)
    print('')
p1 = time.process_time()
print(p1 - p0)
