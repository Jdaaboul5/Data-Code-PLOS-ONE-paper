import numpy as np
import itertools
from itertools import permutations
import copy
import time

p0 = time.process_time()

# Parameters

# Parameters for products
I = [0, 1]  # Set of products
D = [20, 40]  # Due date for each product
W = [2, 1]  # Penalty of unit time tardiness for each product

# Parameters for operations
OP = [0, 1, 2]  # Set of operations
MG = [[[1, 0], [1, 0, 0]],
      [[0, 1], [0, 1, 0]],
      [[0, 1], [0, 0, 1]]]

# Parameters for part variants
V = [0, 1]  # Set of part variants
# Transfer time for moving a WIP belonging to each part variant in unit distance
FT = [1, 3]
# Transfer cost for moving a WIP belonging to each part variant in unit distance
FC = [2, 4]
# Holding cost for holding a WIP belonging to each part variant in unit time
HC = [0.5, 0.6]
# Set of operations for each part variant
VP = [[0, 1, 2],
      [0, 1, 2]]

# Parameters for part variants-operations
# Set of operations precedent to each operation in processing each part variant
K = [[[], [0], [0]],
     [[], [], [0, 1]]]
# Time for each operation in processing each part variant on the corresponding
# machine and configuration pair
PT = [[[[2, 0], [4, 0, 0]],
       [[0, 6], [0, 8, 0]],
       [[0, 6], [0, 0, 4]]],
      [[[2, 0], [4, 0, 0]],
       [[0, 8], [0, 6, 0]],
       [[0, 4], [0, 0, 2]]]]
# Cost for each operation in processing each part variant on the corresponding
# machine and configuration pair
PC = [[[[9, 0], [7, 0, 0]],
       [[0, 5], [0, 3, 0]],
       [[0, 1], [0, 0, 3]]],
      [[[5, 0], [7, 0, 0]],
       [[0, 9], [0, 7, 0]],
       [[0, 5], [0, 0, 3]]]]
# Setup time for each operation in processing each part variant on the
# corresponding machine and configuration pair
ST = [[[[3, 0], [4, 0, 0]],
       [[0, 2], [0, 1, 0]],
       [[0, 4], [0, 0, 5]]],
      [[[5, 0], [3, 0, 0]],
       [[0, 1], [0, 2, 0]],
       [[0, 4], [0, 0, 5]]]]
# Setup cost for each operation in processing each part variant on the
# corresponding machine and configuration pair
SC = [[[[8, 0], [6, 0, 0]],
       [[0, 7], [0, 9, 0]],
       [[0, 9], [0, 0, 7]]],
      [[[9, 0], [9, 0, 0]],
       [[0, 8], [0, 6, 0]],
       [[0, 7], [0, 0, 8]]]]

# Parameters for products-part variants
J = [[1, 0],
     [0, 1]]  # Number of each part variant in each product

# Parameters for workshop
BX = 12
BY = 9

# Parameters for machines
M = [0, 1]  # Number of machines
LC = [1, 2]  # Layout cost for moving each machine in unit distance
X = [2, 8]  # Initial location for each machine on the X-coordinate
Y = [7, 3]  # Initial location for each machine on the Y-coordinate
SX = [1, 3]  # Security distance for each machine on the X-coordinate
SY = [1, 2]  # Security distance for each machine on the Y-coordinate

# Parameters for configurations
G = [2, 3]  # Number of configurations on each machine
# Reconfiguration time between configurations on each machine
RT = [[[0, 1], [3, 0]],
      [[0, 5, 7], [9, 0, 7], [5, 3, 0]]]
# Reconfiguration cost between configurations on each machine
RC = [[[0, 2], [4, 0]],
      [[0, 6, 8], [6, 0, 4], [2, 4, 0]]]

# total operations
opn = 0
for i in I:
    for v in V:
        if J[i][v] != 0:
            for j in range(J[i][v]):
                opn = opn + len(VP[v])

# Feasible operation sequences for part variants
qv = [[] for v in V]
for v in V:
    for item in itertools.permutations(VP[v]):
        for q in item:
            if K[v][q]:
                if not set(K[v][q]).issubset(set(
                        list(item)[:list(item).index(q)])):
                    break
        else:
            qv[v].append(list(item))

# Feasible machine and configuration pairs for each operation
mg = [[] for e in OP]
for e in OP:
    for m in M:
        for g in range(G[m]):
            if MG[e][m][g] == 1:
                mg[e].append([m, g])


# Feasible process plan for each part variant
class pmg:

    def __init__(self, v):
        self.p = []
        self.m = []
        self.g = []
        self.v = v
        for s in qv[v]:
            if len(s) == 1:
                for c in mg[s[0]]:
                    self.p.append(s)
                    self.m.append(c[0])
                    self.g.append(c[1])
            elif len(s) == 2:
                for item in itertools.product(mg[s[0]], mg[s[1]]):
                    self.p.append(s)
                    tm = []
                    tg = []
                    for c in item:
                        tm.append(c[0])
                        tg.append(c[1])
                    self.m.append(tm)
                    self.g.append(tg)
            else:
                ts = [list(item) for item in
                      itertools.product(mg[s[0]], mg[s[1]])]
                for q in range(2, len(s)):
                    tmp = [list(item) for item in
                           itertools.product(ts, mg[s[q]])]
                    ts.clear()
                    for item in tmp:
                        new = copy.deepcopy(item[0])
                        new.append(item[1])
                        ts.append(new)
                for cs in ts:
                    self.p.append(s)
                    tm = []
                    tg = []
                    for c in cs:
                        tm.append(c[0])
                        tg.append(c[1])
                    self.m.append(tm)
                    self.g.append(tg)


fpv = []
for v in V:
    fpv.append(pmg(v))


# Feasible process planning for job sequence
class pp:

    def __init__(self, js):
        self.jp = []
        self.jm = []
        self.jg = []
        if len(js) == 1:
            jv = fpv[js[0][1]]
            self.jp = jv.p
            self.jm = jv.m
            self.jg = jv.g
        elif len(js) == 2:
            jv = [fpv[js[0][1]], fpv[js[1][1]]]
            for item in itertools.product(range(len(jv[0].p)),
                                          range(len(jv[1].p))):
                self.jp.append([jv[0].p[item[0]], jv[1].p[item[1]]])
                self.jm.append([jv[0].m[item[0]], jv[1].m[item[1]]])
                self.jg.append([jv[0].g[item[0]], jv[1].g[item[1]]])
        else:
            jv = [fpv[js[j][1]] for j in range(len(js))]
            tp = [list(item) for item in itertools.product(
                range(len(jv[0].p)), range(len(jv[1].p)))]
            for j in range(2, len(js)):
                tmp = [list(item) for item in
                       itertools.product(tp, range(len(jv[j].p)))]
                tp.clear()
                for item in tmp:
                    new = copy.deepcopy(item[0])
                    new.append(item[1])
                    tp.append(new)
            for i in tp:
                nwp = []
                nwm = []
                nwg = []
                for j in range(len(js)):
                    nwp.append(jv[j].p[i[j]])
                    nwm.append(jv[j].m[i[j]])
                    nwg.append(jv[j].g[i[j]])
                self.jp.append(nwp)
                self.jm.append(nwm)
                self.jg.append(nwg)


jb = []
for i in I:
    for v in V:
        if J[i][v] != 0:
            for j in range(J[i][v]):
                jb.append([i, v, j])

fpp = pp(jb)

# Feasible machine layout solutions
opm = [[] for m in M]
for m in M:
    x = list(range(SX[m], BX - SX[m] + 1))
    y = list(range(SY[m], BY - SY[m] + 1))
    for i in itertools.product(x, y):
        opm[m].append(i)
fm = []
if len(M) == 1:
    fm.append(opm)
elif len(M) == 2:
    for item in itertools.product(opm[0], opm[1]):
        if abs(item[0][0] - item[1][0]) < SX[0] + SX[1] and \
                abs(item[0][1] - item[1][1]) < SY[0] + SY[1]:
            continue
        else:
            fm.append(list(item))
else:
    for item in itertools.product(opm[0], opm[1]):
        fm.append(list(item))
    for i in range(2, len(M)):
        b = itertools.product(fm, opm[i])
        fm.clear()
        for item in b:
            temp = copy.deepcopy(item[0])
            temp.append(item[1])
            for m in range(len(M) - 1):
                for m_ in range(m + 1, len(M)):
                    if abs(temp[m][0] - temp[m_][0]) < SX[m] + SX[m_] and \
                            abs(temp[m][1] - temp[m_][1]) < SY[m] + SY[m_]:
                        break
                else:
                    continue
                break
            else:
                fm.append(temp)
opm.clear()


class slt:

    def __init__(self, slt_x, slt_y, slt_rho, slt_alpha, slt_phi, slt_beta,
                 slt_f1, slt_f2, slt_tlc, slt_tpc, slt_tfc, slt_trc,
                 slt_tsc, slt_thc):
        self.x = slt_x
        self.y = slt_y
        self.rho = slt_rho
        self.alpha = slt_alpha
        self.phi = slt_phi
        self.beta = slt_beta
        self.f1 = slt_f1
        self.f2 = slt_f2
        self.tlc = slt_tlc
        self.tpc = slt_tpc
        self.tfc = slt_tfc
        self.trc = slt_trc
        self.tsc = slt_tsc
        self.thc = slt_thc


class pp_slt:

    def jd(self):
        # Calculate the distance between operations in the operation sequence
        # for each job
        self.delta.clear()
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v]) - 1):
                            self.delta[i][v][j][q] = \
                                abs(self.x[self.alpha[i][v][j][q + 1]] -
                                    self.x[self.alpha[i][v][j][q]]) + \
                                abs(self.y[self.alpha[i][v][j][q + 1]] -
                                    self.y[self.alpha[i][v][j][q]])
                            self.tfc = self.tfc + FC[v] * self.delta[i][v][j][q]
                else:
                    self.delta[i][v] = []
        return self.delta, self.tfc

    def product_completion_time(self):
        # Calculate the completion time for each product
        T = []
        for i in I:
            temp = []
            for v in V:
                if J[i][v] != 0:
                    temp.append(max(self.beta[i][v][j][- 1] +
                                    PT[v][self.rho[i][v][j][- 1]][
                                        self.alpha[i][v][j][- 1]][
                                        self.phi[i][v][j][- 1]]
                                    for j in range(J[i][v])))
                else:
                    temp.append(0)
            T.append(max(temp))
        return T

    # Objective functions
    # First objective function.

    def function1(self):
        # Calculate the tardiness for each product
        C = self.product_completion_time()
        # Calculate the penalty for tardiness
        value = sum(max(0, C[i] - D[i]) * W[i] for i in I)
        return value

    # Second objective function.

    def function2(self):
        value = self.tlc + self.tpc + self.tfc + self.trc + self.tsc + \
                self.thc
        return value

    def __init__(self, mx, my, ro, rf, fi):
        self.pp_slt = []
        self.x = mx
        self.y = my
        self.tlc = 0
        for m in M:
            self.tlc = self.tlc + LC[m] * (abs(self.x[m] - X[m]) +
                                           abs(self.y[m] - Y[m]))
        self.rho = ro
        self.alpha = rf
        self.phi = fi
        self.tpc = 0
        opn = 0
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        opn = opn + len(VP[v])
                        for q in range(len(VP[v])):
                            self.tpc = self.tpc + \
                                       PC[v][self.rho[i][v][j][q]][
                                           self.alpha[i][v][j][q]][
                                           self.phi[i][v][j][q]]
        self.delta = [[[[0 for q in range(len(VP[v]) - 1)]
                        for j in range(J[i][v])] for v in V] for i in I]
        self.tfc = 0
        self.delta, self.tfc = self.jd()
        mes = [[] for m in M]
        mgs = [[] for m in M]
        mis = [[] for m in M]
        mvs = [[] for m in M]
        mjs = [[] for m in M]
        mqs = [[] for m in M]
        for i in I:
            for v in V:
                if J[i][v] != 0:
                    for j in range(J[i][v]):
                        for q in range(len(VP[v])):
                            mes[self.alpha[i][v][j][q]].append(
                                self.rho[i][v][j][q])
                            mgs[self.alpha[i][v][j][q]].append(
                                self.phi[i][v][j][q])
                            mis[self.alpha[i][v][j][q]].append(i)
                            mvs[self.alpha[i][v][j][q]].append(v)
                            mjs[self.alpha[i][v][j][q]].append(j)
                            mqs[self.alpha[i][v][j][q]].append(q)
        f_mes = [[] for m in M]
        f_mgs = [[] for m in M]
        f_mis = [[] for m in M]
        f_mvs = [[] for m in M]
        f_mjs = [[] for m in M]
        f_mqs = [[] for m in M]
        for m in M:
            if len(mes[m]) > 0:
                for item in permutations([i for i in range(len(mes[m]))]):
                    temp_mes = np.array(mes[m])[list(item)]
                    temp_mgs = np.array(mgs[m])[list(item)]
                    temp_mis = np.array(mis[m])[list(item)]
                    temp_mvs = np.array(mvs[m])[list(item)]
                    temp_mjs = np.array(mjs[m])[list(item)]
                    temp_mqs = np.array(mqs[m])[list(item)]
                    jdg = 1
                    for k in range(len(mes[m])):
                        for k_ in range(k):
                            if temp_mis[k] == temp_mis[k_] and \
                                    temp_mvs[k] == temp_mvs[k_] and \
                                    temp_mjs[k] == temp_mjs[k_]:
                                if temp_mqs[k] < temp_mqs[k_]:
                                    jdg = 0
                    if jdg == 1:
                        f_mes[m].append(temp_mes)
                        f_mgs[m].append(temp_mgs)
                        f_mis[m].append(temp_mis)
                        f_mvs[m].append(temp_mvs)
                        f_mjs[m].append(temp_mjs)
                        f_mqs[m].append(temp_mqs)
        mw = []
        for m in M:
            if f_mes[m]:
                mw.append(m)
        if len(mw) == 1:
            m = mw[0]
            for xs in range(len(f_mes[m])):
                self.trc = 0
                self.tsc = 0
                self.thc = 0
                self.beta = [[[[0 for q in range(len(VP[v]))] for j in
                               range(J[i][v])] for v in V] for i in I]
                tt = 0
                ce = - 1
                cg = - 1
                cv = - 1
                for xe in range(len(f_mes[m][xs])):
                    te = f_mes[m][xs][xe]
                    tg = f_mgs[m][xs][xe]
                    ti = f_mis[m][xs][xe]
                    tv = f_mvs[m][xs][xe]
                    tj = f_mjs[m][xs][xe]
                    tq = f_mqs[m][xs][xe]
                    if tt == 0:
                        self.beta[ti][tv][tj][tq] = ST[tv][te][m][tg]
                        self.tsc = SC[tv][te][m][tg]
                    else:
                        if cg == tg:
                            rt = 0
                            rc = 0
                        else:
                            rt = RT[m][cg][tg]
                            rc = RC[m][cg][tg]
                        if cv == tv and ce == te and cg == tg:
                            st = 0
                            sc = 0
                        else:
                            st = ST[tv][te][m][tg]
                            sc = SC[tv][te][m][tg]
                        self.beta[ti][tv][tj][tq] = tt + rt + st
                        self.trc = self.trc + rc
                        self.tsc = self.tsc + sc
                    tt = self.beta[ti][tv][tj][tq] + PT[tv][te][m][tg]
                    ce = te
                    cg = tg
                    cv = tv
                self.f1 = self.function1()
                self.f2 = self.function2()
                self.pp_slt.append(
                    slt(self.x, self.y, self.rho, self.alpha, self.phi,
                        self.beta, self.f1, self.f2, self.tlc, self.tpc,
                        self.tfc, self.trc, self.tsc, self.thc))
        elif len(mw) == 2:
            for xs in itertools.product(range(len(f_mes[mw[0]])),
                                        range(len(f_mes[mw[1]]))):
                self.trc = 0
                self.tsc = 0
                self.thc = 0
                self.beta = [[[[0 for q in range(len(VP[v]))] for j in
                               range(J[i][v])] for v in V] for i in I]
                tt = [0 for m in range(len(mw))]
                ce = [- 1 for m in range(len(mw))]
                cg = [- 1 for m in range(len(mw))]
                cv = [- 1 for m in range(len(mw))]
                fn = []
                xe = [0 for m in range(len(mw))]
                cnt = 0
                for m in range(len(mw)):
                    if f_mqs[mw[m]][xs[m]][0] == 0:
                        te = f_mes[mw[m]][xs[m]][0]
                        tg = f_mgs[mw[m]][xs[m]][0]
                        ti = f_mis[mw[m]][xs[m]][0]
                        tv = f_mvs[mw[m]][xs[m]][0]
                        tj = f_mjs[mw[m]][xs[m]][0]
                        tq = f_mqs[mw[m]][xs[m]][0]
                        self.beta[ti][tv][tj][tq] = ST[tv][te][mw[m]][tg]
                        sc = SC[tv][te][mw[m]][tg]
                        self.tsc = self.tsc + sc
                        tt[m] = self.beta[ti][tv][tj][tq] + \
                                PT[tv][te][mw[m]][tg]
                        ce[m] = te
                        cg[m] = tg
                        cv[m] = tv
                        fn.append([ti, tv, tj, tq])
                        xe[m] = 1
                        cnt = cnt + 1
                m = 0
                km = 0
                while cnt < opn:
                    if km == 2:
                        break
                    if xe[m] < len(f_mes[mw[m]][xs[m]]):
                        te = f_mes[mw[m]][xs[m]][xe[m]]
                        tg = f_mgs[mw[m]][xs[m]][xe[m]]
                        ti = f_mis[mw[m]][xs[m]][xe[m]]
                        tv = f_mvs[mw[m]][xs[m]][xe[m]]
                        tj = f_mjs[mw[m]][xs[m]][xe[m]]
                        tq = f_mqs[mw[m]][xs[m]][xe[m]]
                        if tq == 0:
                            if cg[m] == tg:
                                rt = 0
                                rc = 0
                            else:
                                rt = RT[mw[m]][cg[m]][tg]
                                rc = RC[mw[m]][cg[m]][tg]
                            if cv[m] == tv and ce[m] == te and cg[m] == tg:
                                st = 0
                                sc = 0
                            else:
                                st = ST[tv][te][mw[m]][tg]
                                sc = SC[tv][te][mw[m]][tg]
                            self.beta[ti][tv][tj][tq] = tt[m] + rt + st
                            self.trc = self.trc + rc
                            self.tsc = self.tsc + sc
                            km = 0
                        elif [ti, tv, tj, tq - 1] in fn:
                            if cg[m] == tg:
                                rt = 0
                                rc = 0
                            else:
                                rt = RT[mw[m]][cg[m]][tg]
                                rc = RC[mw[m]][cg[m]][tg]
                            if cv[m] == tv and ce[m] == te and cg[m] == tg:
                                st = 0
                                sc = 0
                            else:
                                st = ST[tv][te][mw[m]][tg]
                                sc = SC[tv][te][mw[m]][tg]
                            tm = tt[m] + rt + st
                            if self.delta[ti][tv][tj][tq - 1] > 0:
                                tf = self.beta[ti][tv][tj][tq - 1] + PT[tv][
                                    self.rho[ti][tv][tj][tq - 1]][
                                    self.alpha[ti][tv][tj][tq - 1]][
                                    self.phi[ti][tv][tj][tq - 1]] + FT[tv] \
                                     * self.delta[ti][tv][tj][tq - 1]
                            else:
                                tf = tm
                            th = tm - tf
                            if th >= 0:
                                self.beta[ti][tv][tj][tq] = tm
                                hc = th * HC[tv]
                            else:
                                self.beta[ti][tv][tj][tq] = tf
                                hc = 0
                            self.trc = self.trc + rc
                            self.tsc = self.tsc + sc
                            self.thc = self.thc + hc
                            km = 0
                        else:
                            m = m + 1
                            if m == 2:
                                m = 0
                            km = km + 1
                            continue
                        tt[m] = self.beta[ti][tv][tj][tq] + \
                                PT[tv][te][mw[m]][tg]
                        ce[m] = te
                        cg[m] = tg
                        cv[m] = tv
                        fn.append([ti, tv, tj, tq])
                        xe[m] = xe[m] + 1
                        cnt = cnt + 1
                    else:
                        m = m + 1
                        if m == 2:
                            m = 0
                        km = km + 1
                if km == 2:
                    continue
                self.f1 = self.function1()
                self.f2 = self.function2()
                self.pp_slt.append(
                    slt(self.x, self.y, self.rho, self.alpha, self.phi,
                        self.beta, self.f1, self.f2, self.tlc, self.tpc,
                        self.tfc, self.trc, self.tsc, self.thc))
        else:
            ts = [list(item) for item in itertools.product(range(len(
                f_mes[mw[0]])), range(len(f_mes[mw[1]])))]
            for m in range(2, len(mw)):
                tmp = [list(item) for item in itertools.product(
                    ts, range(len(f_mes[mw[m]])))]
                ts.clear()
                for item in tmp:
                    new = copy.deepcopy(item[0])
                    new.append(item[1])
                    ts.append(new)
            for xs in ts:
                self.trc = 0
                self.tsc = 0
                self.thc = 0
                self.beta = [[[[0 for q in range(len(VP[v]))] for j in
                               range(J[i][v])] for v in V] for i in I]
                tt = [0 for m in range(len(mw))]
                ce = [- 1 for m in range(len(mw))]
                cg = [- 1 for m in range(len(mw))]
                cv = [- 1 for m in range(len(mw))]
                fn = []
                xe = [0 for m in range(len(mw))]
                cnt = 0
                for m in range(len(mw)):
                    if f_mqs[mw[m]][xs[m]][0] == 0:
                        te = f_mes[mw[m]][xs[m]][0]
                        tg = f_mgs[mw[m]][xs[m]][0]
                        ti = f_mis[mw[m]][xs[m]][0]
                        tv = f_mvs[mw[m]][xs[m]][0]
                        tj = f_mjs[mw[m]][xs[m]][0]
                        tq = f_mqs[mw[m]][xs[m]][0]
                        self.beta[ti][tv][tj][tq] = ST[tv][te][mw[m]][tg]
                        sc = SC[tv][te][mw[m]][tg]
                        self.tsc = self.tsc + sc
                        tt[m] = self.beta[ti][tv][tj][tq] + \
                                PT[tv][te][mw[m]][tg]
                        ce[m] = te
                        cg[m] = tg
                        cv[m] = tv
                        fn.append([ti, tv, tj, tq])
                        xe[m] = 1
                        cnt = cnt + 1
                m = 0
                km = 0
                while cnt < opn:
                    if km == len(mw):
                        break
                    if xe[m] < len(f_mes[mw[m]][xs[m]]):
                        te = f_mes[mw[m]][xs[m]][xe[m]]
                        tg = f_mgs[mw[m]][xs[m]][xe[m]]
                        ti = f_mis[mw[m]][xs[m]][xe[m]]
                        tv = f_mvs[mw[m]][xs[m]][xe[m]]
                        tj = f_mjs[mw[m]][xs[m]][xe[m]]
                        tq = f_mqs[mw[m]][xs[m]][xe[m]]
                        if tq == 0:
                            if cg[m] == tg:
                                rt = 0
                                rc = 0
                            else:
                                rt = RT[mw[m]][cg[m]][tg]
                                rc = RC[mw[m]][cg[m]][tg]
                            if cv[m] == tv and ce[m] == te and cg[m] == tg:
                                st = 0
                                sc = 0
                            else:
                                st = ST[tv][te][mw[m]][tg]
                                sc = SC[tv][te][mw[m]][tg]
                            self.beta[ti][tv][tj][tq] = tt[m] + rt + st
                            self.trc = self.trc + rc
                            self.tsc = self.tsc + sc
                            km = 0
                        elif [ti, tv, tj, tq - 1] in fn:
                            if cg[m] == tg:
                                rt = 0
                                rc = 0
                            else:
                                rt = RT[mw[m]][cg[m]][tg]
                                rc = RC[mw[m]][cg[m]][tg]
                            if cv[m] == tv and ce[m] == te and cg[m] == tg:
                                st = 0
                                sc = 0
                            else:
                                st = ST[tv][te][mw[m]][tg]
                                sc = SC[tv][te][mw[m]][tg]
                            tm = tt[m] + rt + st
                            if self.delta[ti][tv][tj][tq - 1] > 0:
                                tf = self.beta[ti][tv][tj][tq - 1] + PT[tv][
                                    self.rho[ti][tv][tj][tq - 1]][
                                    self.alpha[ti][tv][tj][tq - 1]][
                                    self.phi[ti][tv][tj][tq - 1]] + FT[tv] * \
                                     self.delta[ti][tv][tj][tq - 1]
                            else:
                                tf = tm
                            th = tm - tf
                            if th >= 0:
                                self.beta[ti][tv][tj][tq] = tm
                                hc = th * HC[tv]
                            else:
                                self.beta[ti][tv][tj][tq] = tf
                                hc = 0
                            self.trc = self.trc + rc
                            self.tsc = self.tsc + sc
                            self.thc = self.thc + hc
                            km = 0
                        else:
                            m = m + 1
                            if m == len(mw):
                                m = 0
                            km = km + 1
                            continue
                        tt[m] = self.beta[ti][tv][tj][tq] + \
                                PT[tv][te][mw[m]][tg]
                        ce[m] = te
                        cg[m] = tg
                        cv[m] = tv
                        fn.append([ti, tv, tj, tq])
                        xe[m] = xe[m] + 1
                        cnt = cnt + 1
                    else:
                        m = m + 1
                        if m == len(mw):
                            m = 0
                        km = km + 1
                if km == len(mw):
                    continue
                self.f1 = self.function1()
                self.f2 = self.function2()
                self.pp_slt.append(
                    slt(self.x, self.y, self.rho, self.alpha, self.phi,
                        self.beta, self.f1, self.f2, self.tlc, self.tpc,
                        self.tfc, self.trc, self.tsc, self.thc))


# Main program starts here
ttl_slt = []
pr = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
       for v in V] for i in I]
pa = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
       for v in V] for i in I]
ph = [[[[0 for q in range(len(VP[v]))] for j in range(J[i][v])]
       for v in V] for i in I]
for ly in fm:
    px = [ly[m][0] for m in M]
    py = [ly[m][1] for m in M]
    for p in range(len(fpp.jp)):
        for jd in range(len(jb)):
            i = jb[jd][0]
            v = jb[jd][1]
            j = jb[jd][2]
            for q in range(len(VP[v])):
                pr[i][v][j][q] = fpp.jp[p][jd][q]
                pa[i][v][j][q] = fpp.jm[p][jd][q]
                ph[i][v][j][q] = fpp.jg[p][jd][q]
        sp = pp_slt(px, py, pr, pa, ph)
        temp = copy.deepcopy(sp.pp_slt)
        ttl_slt.extend(temp)
V1 = [s.f1 for s in ttl_slt]
V2 = [s.f2 for s in ttl_slt]
ds = [0 for i in range(len(ttl_slt))]
for v in range(len(ttl_slt) - 1):
    if ds[v] == - 1:
        continue
    for u in range(v + 1, len(ttl_slt)):
        if ds[u] == - 1:
            continue
        if (V1[u] < V1[v] and V2[u] < V2[v]) or \
                (V1[u] == V1[v] and V2[u] < V2[v]) or \
                (V1[u] < V1[v] and V2[u] == V2[v]):
            ds[v] = - 1
        if (V1[v] < V1[u] and V2[v] < V2[u]) or \
                (V1[v] == V1[u] and V2[v] < V2[u]) or \
                (V1[v] < V1[u] and V2[v] == V2[u]):
            ds[u] = - 1
opt_f1 = []
opt_f2 = []
for i in range(len(ttl_slt)):
    if ds[i] == 0:
        opt_f1.append(ttl_slt[i].f1)
        opt_f2.append(ttl_slt[i].f2)
        print(ttl_slt[i].f1, ttl_slt[i].f2)
        print(ttl_slt[i].x, ttl_slt[i].y)
        print(ttl_slt[i].rho)
        print(ttl_slt[i].alpha)
        print(ttl_slt[i].phi)
        print(ttl_slt[i].beta)
        print('')
p1 = time.process_time()
print(p1 - p0)
